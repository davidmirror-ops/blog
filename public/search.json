[{"categories":null,"content":"Helm is the most popular and almost de-facto package manager for Kubernetes. In this post I summarize what I learned after reading Learning Helm, written by some of the Helm maintainers.\nTo be honest, the first time I heard about “package management” for Kubernetes, I was a bit confused. The term is familiar to me for operating systems (i.e. apt for Ubuntu or yum for RHEL/CentOS), but I wasn’t sure what was the meaning in a Kubernetes context.\nIn Helm, a “package” contains the application and all the K8s resources it requires to operate. It could be a Deployment, ReplicaSet, Service, Ingress, Secrets, etc. The the goal of package management in Kubernetes is to simplify the definition of these requirements , and automate their lifecycle while keeping its declarative nature.\nThe Chart is the main Helm construct and it declares the way an application should be installed on a Kubernetes cluster. To apply what’s in declarative config, a set of files and directories are also part of the chart and describe the resources to be installed on K8s.\nCharts are stored in repositories (be them local or remote). You just need to add the repo to your local Helm installation and then reference it when needed:\nhelm repo add bitnami \u003chttps://charts.bitnami.com/bitnami\u003e Bitnami is a popular service hosting a number of Helm charts\nAnd then\nhelm install web bitnami/wordpress --dry-run Where\nWeb is the release name. This is the package name or the set of Kubernetes resources configured and managed by Helm. It is user-defined and it’s typically used as part of the name of every K8s resource that Helm creates. bitnami/wordpress the repo and the specific chart to install dry-run useful command to assess the result of the Helm rendering process before any actual resource creation request is sent to the Kubernetes API. It’s a good way to catch syntax errors early. The values.yaml file is the main point of contact between the chart and the user. In this file, users are able to specify details that will enable the packaged application to use resources and configuration from a particular environment.\nIn the following example, which is only a section in a values file, there are some important things to note:\n# commonLabels Add labels to all the deployed resources commonLabels: {} # commonAnnotations Add annotations to all the deployed resources commonAnnotations: {} configuration: database: # username Name for user to connect to database as username: \u003creplace\u003e # password Password to connect to database with password: \"\" # host Hostname of database instance host: 127.0.0.1 # port Port to connect to database at port: 5432 # dbname Name of database to use dbname: \u003creplace\u003e # options Additional client options for connecting to database options: sslmode=disable Keys like commonLabels are bare common variables created by Helm and empty by default (that’s the meaning of {}). If you choose to modify them, just remove the {} and add your preferred configuration: commonLabels: environment: prod There is a high degree of control for chart authors to control the structure of the chart and it’s supporting files, including values.yaml. Regular YAML syntax rules apply (e.g. indentation) but in the example, the entire configuration section was defined by chart authors When keys have a value of \"\" it means that Helm will overwrite whatever the content of the key is with an empty string. You just need to remove the \"\" and insert the required value. Once the values.yaml reflects the configuration for your environment, it is time to install:\nhelm install web bitnami/wordpress --values values.yaml Example output:\nRelease \"web\" has been installed. Happy Helming! NAME: web LAST DEPLOYED: Thu May 4 18:12:40 2023 NAMESPACE: default STATUS: deployed REVISION: 1 TEST SUITE: None Notice that:\nHelm releases are namespaced, except of course for cluster-wide resources like ClusterRole REVISION is the versioning mechanism Helm uses for releases. Whenever you need to update the configuration of a release (for example, by making a change to a field in values.yaml) you just need to run a helm upgrade \u003crelease-name\u003e \u003cchart-name\u003e --namespace \u003cyour-namespace\u003e and Helm will not only update only the resource(s) that needs to be changed but will update the REVISION field to the next number in the sequence (up to 10). Release \"web\" has been upgraded. Happy Helming! NAME: web LAST DEPLOYED: Thu May 4 18:15:40 2023 NAMESPACE: default STATUS: deployed REVISION: 2 TEST SUITE: None This is helpful if you need to perform a rollback. In such case, you just need to refer to the REVISION number:\nhelm history web Example output:\nREVISION UPDATED STATUS CHART APP VERSION DESCRIPTION 1 2023-05-10 10:00:00 deployed wordpress-1.0.0 1.2.3 Initial release 2 2023-05-12 15:30:00 deployed wordpress-1.0.1 1.2.4 Updated configuration and then:\nhelm rollback web 1 Conclusion Kubernetes introduced the idea of declarative configuration for infrastructure in a single API. Helm takes the idea up to the application level enabling app developers and platform operators to declare desired state and manage the lifecycle of Kubernetes resources in a way that’s portable, versioned and more reliable than wrangling YAMLs for different resources and environments.\nHappy helming!\n","description":"","tags":null,"title":"Intro to Helm","uri":"/posts/intro-to-helm/"}]
