[{"categories":null,"content":"Helm is the most popular and almost de-facto package manager for Kubernetes. In this post I summarize what I learned after reading Learning Helm, written by Helm maintainers.\nTo be honest, the first time I heard about “package management” for Kubernetes, I was a bit confused. The term is familiar to me for operating systems (i.e. apt for Ubuntu or yum for RHEL/CentOS), but I wasn’t sure what was the meaning in a Kubernetes context.\nIn Helm, a “package” contains the application and all the K8s resources it requires to operate. It could be a Deployment, ReplicaSet, Service, Ingress, Secrets, etc. How to simplify the definition of these requirements for apps, and automate their lifecycle while keeping its declarative nature, is the goal of package management for Kubernetes.\nA Chart -main Helm construct- declares the way an application should be installed on Kubernetes. To apply what’s in declarative config, a set of files and directories are also part of the chart and describe the resources to be installed on K8s.\nCharts are stored in repositories (be them local or remote). You just need to add the repo to Helm and then reference it when needed:\n1 helm repo add bitnami https://charts.bitnami.com/bitnami Bitnami is a popular service hosting a number of Helm charts\nAnd then\n1 helm install web bitnami/wordpress --dry-run Where\nWeb is the release name. This is the package name or the set of Kubernetes resources configured and managed by Helm. bitnami/wordpress the repo and the specific chart to install dry-run useful command to assess the result of the Helm rendering process before any actual resource creation request is sent to the Kubernetes API. It’s a good way to catch syntax errors early. The values.yaml file is main point of contact between the chart and the user. In this file, users are able to specify details that will enable the packaged application to use resources and configuration from a particular environment.\nIn the following example, which is only a section in a values file, there are some important things to note:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # commonLabels Add labels to all the deployed resources commonLabels: {} # commonAnnotations Add annotations to all the deployed resources commonAnnotations: {} configuration: database: # username Name for user to connect to database as username: \u003creplace\u003e # password Password to connect to database with password: \"\" # host Hostname of database instance host: 127.0.0.1 # port Port to connect to database at port: 5432 # dbname Name of database to use dbname: \u003creplace\u003e # options Additional client options for connecting to database options: sslmode=disable Keys like commonLabels are bare common variables created by Helm and empty by default (that’s the meaning of {}). If you choose to modify them, just remove the {} and add your preferred configuration: 1 2 commonLabels: environment: prod There is a high degree of control for chart authors to control the structure of the chart and it’s supporting files, including values.yaml. Regular YAML syntax rules apply (e.g. indentation) but in the example, the entire configuration section was defined by chart authors When keys have a value of \"\" indicate Helm to overwrite whatever the content of the key is with an empty string. You just need to remove the \"\" and insert the required value. Once the values.yaml reflects the configuration for your environment is time to install\n1 helm install web bitnami/wordpress --values values.yaml Example output:\n1 2 3 4 5 6 7 Release \"web\" has been installed. Happy Helming! NAME: web LAST DEPLOYED: Thu May 4 18:12:40 2023 NAMESPACE: default STATUS: deployed REVISION: 1 TEST SUITE: None Notice that:\nHelm releases are namespaced, except of course for cluster-wide resources like ClusterRole REVISION is the versioning mechanism Helm uses for releases. Whenever you need to update the configuration of a release (for example, by making a change to a field in values.yaml) you just need to run a helm upgrade \u003crelease-name\u003e \u003cchart-name\u003e --namespace \u003cyour-namespace\u003e and Helm will not only update only the resource(s) that needs to be changed but will update the REVISION field to the next number in the sequence (up to 10). This is helpful if you want to try a rollback you just need to refer to the REVISION number: 1 2 3 4 5 6 7 Release \"web\" has been upgraded. Happy Helming! NAME: web LAST DEPLOYED: Thu May 4 18:15:40 2023 NAMESPACE: default STATUS: deployed REVISION: 2 TEST SUITE: None 1 helm history web Example output:\n1 2 3 REVISION UPDATED STATUS CHART APP VERSION DESCRIPTION 1 2023-05-10 10:00:00 deployed wordpress-1.0.0 1.2.3 Initial release 2 2023-05-12 15:30:00 deployed wordpress-1.0.1 1.2.4 Updated configuration Conclusion Kubernetes introduced the idea of declarative configuration for infrastructure in a single API. Helm takes the idea up to the application level enabling app developers and platform operators to declare desired state, managing the lifecycle of Kubernetes resources in a way that’s portable, versioned and more reliable than wrangling YAMLs for different resources and environments.\nHappy helming!\n","description":"","tags":null,"title":"Helm Intro","uri":"/blog/posts/helm-intro/"}]
